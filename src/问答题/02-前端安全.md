# 前端安全

## XSS

> XSS全称：Cross-Site-Scripting（跨站脚本攻击）。为了与CSS做区分，所以叫做XSS。

XSS的基本原理：攻击者在目标网站注入恶意代码，当用户也就是被攻击者访问目标网站的时候就会执行这些恶意的脚本代码，这些脚本代码可以读取cookie，session或者其他敏感信息，对用户进行一些破坏性操作。

XSS的本质:恶意代码未经过滤,与网站正常的代码混在一起;浏览器无法分辨哪些脚本是可信的,导致恶意脚本被执行。由于直接在用户的终端执行,恶意代码能够直接获取用户的信息,利用这些信息冒充用户向网站发起攻击。

### XSS的分类

- 反射型
- DOM型
- 存储型

#### 反射型

> 反射型XSS的攻击一般有个前提：将恶意代码拼接到URL上，然后把这个URL发给用户，用户点击后，服务端把URL直接取出来返回给用户，这个时候用户就会执行恶意的代码。

反射型XSS的攻击步骤:

1.攻击者构造出特殊的URL, 其中包含恶意代码。
2.用户打开带有恶意代码的URL时, 网站服务端将恶意代码从 URL中取出, 拼接在 HTML中返回给浏览器
3.用户浏览器接收到响应后解析执行, 混在其中的恶意代码也被执行。
4.恶意代码窃取用户数据并发送到攻击者的网站, 或者冒充用户的行为, 调用目标网站接口执行攻击者指定的操作。

##### 如何防范

后端对直接返回给URL参数进行编码后返回给前端。

#### DOM型

DOM型也是一种特殊的反射型XSS攻击。
与反射型不同的是，DOM型不会经过服务器。是直接利用恶意构造的URL，将前端代码中的innerHtml,#的跳转，eval，document.write等方式，读取到URL上的恶意代码后就会进行某些操作。

本质是前端使用某些API的时候或者展示某些变量的时候，没有将变量进行编码。

##### 如何防范

本质是前端使用某些API的时候或者展示某些变量的时候将变量进行编码。

#### 存储型

> 反射型和DOM型是危害比较小的，可能只会危害少量的用户，存储型一般来说会危害大量的用户。

原理主要是：用户在提交的时候，将恶意的脚本提交到服务端数据库存储起来。当其他用户访问这份数据的时候，会执行这段恶意的脚本代码，危害性极大。

如何防范：DOM型和反射型，前端在提交或者展示某些内容的时候，将内容进行编码提交或者展示。

## CSRF

> CSRF的全称：Cross-site request forgery（跨站请求伪造）。
> 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击者网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的CSRF攻击有着如下的流程：

- 受害者登录a.com，并保留了登录凭证（Cookie）。
- 攻击者引诱受害者访问了b.com。
- b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

基本原理就是：在向某一个网站的后台发送请求的时候，会自动带上这个网站的Cookie。其实后台不知道这个网站是从哪来的。如果没有做处理的话，就认为就是从正确地方发送的请求。

### 几种常见的CSRF攻击

#### GET类型的CSRF攻击

一般就是点开某个网页，后台默认发送一次HTTP请求，这次HTTP请求就是被攻击的网站的一次请求。

##### POST类型的CSRF

同样也是，点开一个网页，使用form表单自动提交，发送一个post请求。

##### 链接类型的CSRF

链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如

```html
  <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  重磅消息！！
  <a/>
```

这种就是公共场所诱导点击，然后到达了新的网站，新网站像上面一样发送请求，进行伪造。

### CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击网站，被攻击的网站无法防止攻击发生。
- 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是直接窃取信息。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是冒用。
- 跨站请求可以用各种方式：图片URL，超级链，CORS，Form提交等等。部分请求方式可以直接嵌入在第三方论坛，文章中，难以进行追踪。

CSRF通常是跨域的，因为外域通常更容易被攻击者掌握，但是如果本域下有绒里被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。

#### 如何防护

CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。

上文中讲了CSRF的两个特点：

CSRF（通常）发生在第三方域名。
CSRF攻击者不能获取到Cookie等信息，只是使用。
针对这两点，我们可以专门制定防护策略，如下：

- 阻止不明外域的访问
  - 同源检测
  - Samesite Cookie
- 提交时要求附加本域才能获取的信息
  - CSRF Token
  - 双重Cookie验证

##### 同源检测

既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。

那么问题来了，我们如何判断请求是否来自外域呢？

在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：

- Origin Header:Origin 指示了请求来自于哪个站点，只有服务器名，不包含路径信息
  - 同源请求：POST、OPTIONS、PUT、PATCH 和 DELETE请求都会添加 Origin请求头，GET或HEAD请求不会添加Origin请求头。
  - 跨域请求：所有跨域请求(CORS)都会添加Origin请求头。
- Referer Header：表示请求Origin的请求域名。
  - Referer 指示了请求来自于哪个具体页面，包含服务器名和路径的详细URL，浏览器自动添加到http请求 Header 中，无需手动设置。

这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。

1. 我们可以通过Origin Header确定来源域名。
   1. 如果Origin Header存在的话，我们直接使用Origin中的字段来确认来源域名。
   2. 如果不存在则就只能换成其他的。
2. 通过Referer Header确定来源域名

#### CSRF-Token

第一次打开页面：得到token，将后续页面中所有的dom上都加上Token，所有的请求页带上token，然后服务器验证token是否一致。

#### 验证码

#### Samesite Cookie属性
